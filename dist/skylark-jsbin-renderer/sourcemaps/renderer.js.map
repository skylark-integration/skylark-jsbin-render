{"version":3,"sources":["renderer.js"],"names":["define","Deferred","$","jsbin","size","hide","embedResizeDone","renderer","$document","window","document","runner","origin","setup","runnerFrame","contentWindow","iframe","error","console","warn","apply","concat","slice","call","arguments","handleMessage","event","data","JSON","parse","e","message","type","postMessage","stringify","complete","store","sessionStorage","removeItem","loopProtectHit","line","cm","panels","named","javascript","editor","setTimeout","annotations","state","lint","updateLinting","filter","a","source","push","from","CodeMirror","Pos","to","severity","options","delay","resize","$live","find","throttle","fadeOut","embed","show","html","width","self","top","height","$body","outerHeight","offsetHeight","parent","focus","live","closedropdown","method","args","_console","url","trigger","err"],"mappings":";;;;;;;AAAAA,QACE,+BACA,iBACC,WACD,SAAUC,EAASC,EAAEC,GACnB,aASA,IAoJMC,EAEAC,EAIAC,EA1JFC,KAEAC,GADUN,EAAEO,QACAP,EAAEQ,WA2SpB,OArSEH,EAASI,UACTJ,EAASI,OAAOC,OAAS,IAKzBL,EAASM,MAAQ,SAAUC,GACzBP,EAASI,OAAOF,OAASK,EAAYC,cACrCR,EAASI,OAAOK,OAASF,GAM3BP,EAASU,MAAQ,WAIfR,OAAOS,QAAQC,KAAKC,MAAMF,SAAU,aAAaG,UAAUC,MAAMC,KAAKC,cAMxEjB,EAASkB,cAAgB,SAAUC,GACjC,GAAKA,EAAMd,OAAX,CACA,IAAIe,EAAOD,EAAMC,KAEjB,GAAoB,iBAATA,EAAX,CAoBA,IACEA,EAA6B,iBAAfD,EAAMC,KAAoBC,KAAKC,MAAMH,EAAMC,MAAQD,EAAMC,KACvE,MAAOG,GACP,OAAOvB,EAASU,MAAM,4BAA6Ba,EAAEC,SAuBvD,GAAmC,mBAAxBxB,EAASoB,EAAKK,MACvB,OAAO,EAET,IACEzB,EAASoB,EAAKK,MAAML,EAAKA,MACzB,MAAOG,GACPvB,EAASU,MAAMa,EAAEC,aAOrBxB,EAAS0B,YAAc,SAAUD,EAAML,GACrC,IAAKpB,EAASI,OAAOF,OACnB,OAAOF,EAASU,MAAM,gDAExBV,EAASI,OAAOF,OAAOwB,YAAYL,KAAKM,WACtCF,KAAMA,EACNL,KAAMA,IACJpB,EAASI,OAAOC,SAOtBL,EAAS4B,SAAW,WAClB,IACEC,MAAMC,eAAeC,WAAW,iBAChC,MAAOR,MAMXvB,EAASgC,eAAiB,SAAUC,GAClC,IAAIC,EAAKtC,EAAMuC,OAAOC,MAAMC,WAAWC,OAKvCC,WAAW,WACT,IAAIC,EAAcN,EAAGO,MAAMC,KAAKF,qBACA,IAArBN,EAAGS,iBAEZH,EAAcA,EAAYI,OAAO,SAAUC,GACzC,OAAOA,EAAEC,SAAW,mBAAqBb,KAE/Bc,MACVC,KAAMC,WAAWC,IAAIjB,EAAK,EAAG,GAC7BkB,GAAIF,WAAWC,IAAIjB,EAAK,EAAG,GAC3BT,QAAS,gGACT4B,SAAU,UACVN,OAAQ,mBAAqBb,IAG/BC,EAAGS,cAAcH,KAElBN,EAAGO,MAAMC,KAAKW,QAAQC,OAAS,IAMpCtD,EAASuD,QACH1D,EAAOG,EAASwD,MAAMC,KAAK,SAE3B3D,EAAO4D,SAAS,WAClB7D,EAAK8D,QAAQ,MACZ,KAEC5D,GAAkB,EAEf,SAAUqB,GAMf,GALKxB,EAAMgE,QAET/D,EAAKgE,OAAOC,KAAK1C,EAAK2C,MAAQ,MAC9BjE,KAEEF,EAAMgE,OAASI,OAASC,MAA2B,IAApBlE,EAA2B,CAC5DA,GAAkB,EAElB,IAAImE,EAAUC,MAAMC,aAAY,GAAQzE,EAAEK,EAASI,OAAOK,QAAQyD,SAAY9C,EAAKiD,aACpFnE,OAAOoE,OAAO5C,aAAcwC,OAAQA,GAAU,QAQnDlE,EAASuE,MAAQ,WACf3E,EAAMuC,OAAOoC,MAAM3E,EAAMuC,OAAOC,MAAMoC,MAEtCC,iBAMFzE,EAASW,QAAU,SAAUS,GAC3B,IAAIsD,EAAStD,EAAKsD,OACdC,EAAOvD,EAAKuD,KAEXzE,OAAO0E,WACP1E,OAAO0E,SAASF,KAAUA,EAAS,OAKxCxE,OAAO0E,SAASF,GAAQ7D,MAAMX,OAAO0E,SAAUD,KAMjD3E,EAAS,+BAAiC,SAAU6E,GAClD5E,EAAU6E,QAAQ,8BAA+BD,IAGnD7E,EAAS,6BAA+B,SAAU+E,GAChD9E,EAAU6E,QAAQ,4BAA6BC,IAOjD/E,EAAS,4BAA8B,SAAU6E,GAC/C5E,EAAU6E,QAAQ,2BAA4BD,IAGhD7E,EAAS,0BAA4B,SAAU+E,GAC7C9E,EAAU6E,QAAQ,yBAA0BC,IAqFzCnF,EAAMI,SAAWA","file":"../renderer.js","sourcesContent":["define([\r\n  \"skylark-langx-async/Deferred\",\r\n  \"skylark-jquery\",\r\n   \"./jsbin\"\r\n],function (Deferred,$,jsbin) {\r\n    'use strict';\r\n    // move from render/live.js\r\n\r\n  /** ============================================================================\r\n   * JS Bin Renderer\r\n   * Messages to and from the runner.\r\n   * ========================================================================== */\r\n\r\n\r\n    var renderer = {},\r\n        $window = $(window),\r\n        $document = $(document);\r\n\r\n    /**\r\n     * Store what runner origin *should* be\r\n     * TODO this should allow anything if x-origin protection should be disabled\r\n     */\r\n    renderer.runner = {};\r\n    renderer.runner.origin = '*';\r\n\r\n    /**\r\n     * Setup the renderer\r\n     */\r\n    renderer.setup = function (runnerFrame) {\r\n      renderer.runner.window = runnerFrame.contentWindow;\r\n      renderer.runner.iframe = runnerFrame;\r\n    };\r\n\r\n    /**\r\n     * Log error messages, indicating that it's from the renderer.\r\n     */\r\n    renderer.error = function () {\r\n      // it's quite likely that the error that fires on this handler actually comes\r\n      // from another service on the page, like a browser plugin, which we can\r\n      // safely ignore.\r\n      window.console.warn.apply(console, ['Renderer:'].concat([].slice.call(arguments)));\r\n    };\r\n\r\n    /**\r\n     * Handle all incoming postMessages to the renderer\r\n     */\r\n    renderer.handleMessage = function (event) {\r\n      if (!event.origin) return;\r\n      var data = event.data;\r\n\r\n      if (typeof data !== 'string') {\r\n        // this event isn't for us (i.e. comes from a browser ext)\r\n        return;\r\n      }\r\n\r\n      // specific change to handle reveal embedding\r\n      /*\r\n       // Unnecessary? //lwf\r\n      try {\r\n        if (event.data.indexOf('slide:') === 0 || event.data === 'jsbin:refresh') {\r\n          // reset the state of the panel visibility\r\n          jsbin.panels.allEditors(function (p) {\r\n            p.visible = false;\r\n          });\r\n          jsbin.panels.restore();\r\n          return;\r\n        }\r\n      } catch (e) {}\r\n      */\r\n\r\n      try {\r\n        data = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;\r\n      } catch (e) {\r\n        return renderer.error('Error parsing event data:', e.message);\r\n      }\r\n\r\n      /*\r\n       // Unnecessary? //lwf\r\n      if (data.type.indexOf('code:') === 0 && jsbin.embed) {\r\n        var panel = data.type.substr(5);\r\n        if (panel === 'js') { panel = 'javascript'; }\r\n        if (' css javascript html '.indexOf(' ' + panel + ' ') === -1) {\r\n          return renderer.error('No matching event handler:', data.type);\r\n        }\r\n\r\n        if (!jsbin.state.metadata.pro) {\r\n          return renderer.error('Code injection is only supported on pro created bins');\r\n        }\r\n\r\n        jsbin.panels.named[panel].setCode(data.data);\r\n        renderLivePreview();\r\n\r\n        return;\r\n      }\r\n      */\r\n\r\n      if (typeof renderer[data.type] !== 'function') {\r\n        return false; //renderer.error('No matching handler for event', data);\r\n      }\r\n      try {\r\n        renderer[data.type](data.data);\r\n      } catch (e) {\r\n        renderer.error(e.message);\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Send message to the runner window\r\n     */\r\n    renderer.postMessage = function (type, data) {\r\n      if (!renderer.runner.window) {\r\n        return renderer.error('postMessage: No connection to runner window.');\r\n      }\r\n      renderer.runner.window.postMessage(JSON.stringify({\r\n        type: type,\r\n        data: data\r\n      }), renderer.runner.origin);\r\n    };\r\n\r\n    /**\r\n     * When the renderer is complete, it means we didn't hit an initial\r\n     * infinite loop\r\n     */\r\n    renderer.complete = function () {\r\n      try {\r\n        store.sessionStorage.removeItem('runnerPending');\r\n      } catch (e) {}\r\n    };\r\n\r\n    /**\r\n     * Pass loop protection hit calls up to the error UI\r\n     */\r\n    renderer.loopProtectHit = function (line) {\r\n      var cm = jsbin.panels.named.javascript.editor;\r\n\r\n      // grr - more setTimeouts to the rescue. We need this to go in *after*\r\n      // jshint does it's magic, but jshint set on a setTimeout, so we have to\r\n      // schedule after.\r\n      setTimeout(function () {\r\n        var annotations = cm.state.lint.annotations || [];\r\n        if (typeof cm.updateLinting !== 'undefined') {\r\n          // note: this just updated the *source* reference\r\n          annotations = annotations.filter(function (a) {\r\n            return a.source !== 'loopProtectLine:' + line;\r\n          });\r\n          annotations.push({\r\n            from: CodeMirror.Pos(line-1, 0),\r\n            to: CodeMirror.Pos(line-1, 0),\r\n            message: 'Exiting potential infinite loop.\\nTo disable loop protection: add \"// noprotect\" to your code',\r\n            severity: 'warning',\r\n            source: 'loopProtectLine:' + line\r\n          });\r\n\r\n          cm.updateLinting(annotations);\r\n        }\r\n      }, cm.state.lint.options.delay || 0);\r\n    };\r\n\r\n    /**\r\n     * When the iframe resizes, update the size text\r\n     */\r\n    renderer.resize = (function () {\r\n      var size = renderer.$live.find('.size');\r\n\r\n      var hide = throttle(function () {\r\n        size.fadeOut(200);\r\n      }, 2000);\r\n\r\n      var embedResizeDone = false;\r\n\r\n      return function (data) {\r\n        if (!jsbin.embed) {\r\n          // Display the iframe size in px in the JS Bin UI\r\n          size.show().html(data.width + 'px');\r\n          hide();\r\n        }\r\n        if (jsbin.embed && self !== top && embedResizeDone === false) {\r\n          embedResizeDone = true;\r\n          // Inform the outer page of a size change\r\n          var height = ($body.outerHeight(true) - $(renderer.runner.iframe).height()) + data.offsetHeight;\r\n         window.parent.postMessage({ height: height }, '*');\r\n        }\r\n      };\r\n    }());\r\n\r\n    /**\r\n     * When the iframe focuses, simulate that here\r\n     */\r\n    renderer.focus = function () {\r\n      jsbin.panels.focus(jsbin.panels.named.live);\r\n      // also close any open dropdowns\r\n      closedropdown();\r\n    };\r\n\r\n    /**\r\n     * Proxy console logging to JS Bin's console\r\n     */\r\n    renderer.console = function (data) {\r\n      var method = data.method,\r\n          args = data.args;\r\n\r\n      if (!window._console) {return;}\r\n      if (!window._console[method]) {method = 'log';}\r\n\r\n      // skip the entire console rendering if the console is hidden\r\n      ///if (!jsbin.panels.named.console.visible) { return; }\r\n\r\n      window._console[method].apply(window._console, args);\r\n    };\r\n\r\n    /**\r\n     * Load scripts into rendered iframe\r\n     */\r\n    renderer['console:load:script:success'] = function (url) {\r\n      $document.trigger('console:load:script:success', url);\r\n    };\r\n\r\n    renderer['console:load:script:error'] = function (err) {\r\n      $document.trigger('console:load:script:error', err);\r\n    };\r\n\r\n    /**\r\n     * Load DOME into rendered iframe\r\n     * TODO abstract these so that they are automatically triggered\r\n     */\r\n    renderer['console:load:dom:success'] = function (url) {\r\n      $document.trigger('console:load:dom:success', url);\r\n    };\r\n\r\n    renderer['console:load:dom:error'] = function (err) {\r\n      $document.trigger('console:load:dom:error', err);\r\n    };\r\n\r\n\r\n   // Runner iframe  \r\n   var  iframe,\r\n        inited;\r\n  /**\r\n   * Render live preview.\r\n   * Create the runner iframe, and if postMe wait until the iframe is loaded to\r\n   * start postMessaging the runner.\r\n   */\r\n  function init($live,runner) {\r\n\r\n    if (inited) {\r\n      return inited.promise;\r\n    }\r\n\r\n    inited = new Deferred();\r\n\r\n    renderer.$live = $live;\r\n\r\n    // Basic mode\r\n    // This adds the runner iframe to the page. It's only run once.\r\n    //if (!$live.find('iframe').length) {\r\n      iframe = document.createElement('iframe');\r\n      iframe.setAttribute('class', 'stretch');\r\n      iframe.setAttribute('sandbox', 'allow-modals allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts');\r\n      iframe.setAttribute('frameBorder', '0');\r\n      iframe.setAttribute('name', '<proxy>');\r\n      $live.prepend(iframe);\r\n      iframe.src = jsbin.runner;\r\n      try {\r\n        iframe.contentWindow.name = '/' + jsbin.state.code + '/' + jsbin.state.revision;\r\n      } catch (e) {\r\n        // ^- this shouldn't really fail, but if we're honest, it's a fucking mystery as to why it even works.\r\n        // problem is: if this throws (because iframe.contentWindow is undefined), then the execution exits\r\n        // and `var renderLivePreview` is set to undefined. The knock on effect is that the calls to renderLivePreview\r\n        // then fail, and jsbin doesn't boot up. Tears all round, so we catch.\r\n      }\r\n    //}\r\n\r\n    iframe.onload = function () {\r\n      if (window.postMessage) {\r\n        // setup postMessage listening to the runner\r\n        $window.on('message', function (event) {\r\n          renderer.handleMessage(event.originalEvent)\r\n        });\r\n        renderer.setup(iframe);\r\n        inited.resolve();\r\n      }\r\n    };\r\n\r\n    iframe.onerror = function(err) {\r\n      inited.reject(err);\r\n    };\r\n\r\n    /**\r\n     * Events\r\n     */\r\n\r\n    $document.on('codeChange.live', function (event, arg) {\r\n      if (arg.origin === 'setValue' || arg.origin === undefined) {\r\n        return;\r\n      }\r\n      store.sessionStorage.removeItem('runnerPending');\r\n    });\r\n\r\n    // Listen for console input and post it to the iframe\r\n    $document.on('console:run', function (event, cmd) {\r\n      renderer.postMessage('console:run', cmd);\r\n    });\r\n\r\n    $document.on('console:load:script', function (event, url) {\r\n      renderer.postMessage('console:load:script', url);\r\n    });\r\n\r\n    $document.on('console:load:dom', function (event, html) {\r\n      renderer.postMessage('console:load:dom', html);\r\n    });\r\n\r\n    return inited.promise;\r\n  }\r\n\r\n\r\n  return jsbin.renderer = renderer;\r\n\r\n});\r\n"]}