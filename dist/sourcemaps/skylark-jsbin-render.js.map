{"version":3,"sources":["skylark-jsbin-render.js"],"names":["define","skylark","attach","Deferred","$","jsbin","size","hide","embedResizeDone","renderer","$document","window","document","runner","origin","setup","runnerFrame","contentWindow","iframe","error","console","warn","apply","concat","slice","call","arguments","handleMessage","event","data","JSON","parse","e","message","type","postMessage","stringify","complete","store","sessionStorage","removeItem","loopProtectHit","line","cm","panels","named","javascript","editor","setTimeout","annotations","state","lint","updateLinting","filter","a","source","push","from","CodeMirror","Pos","to","severity","options","delay","resize","$live","find","throttle","fadeOut","embed","show","html","width","self","top","height","$body","outerHeight","offsetHeight","parent","focus","live","closedropdown","method","args","_console","url","trigger","err","main"],"mappings":"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","file":"../skylark-jsbin-render.js","sourcesContent":["define('skylark-jsbin-render/jsbin',[\r\n\t\"skylark-langx-ns\"\r\n],function(skylark){\r\n\treturn skylark.attach(\"intg.jsbin\");\r\n});\ndefine('skylark-jsbin-render/renderer',[\r\n  \"skylark-langx-async/Deferred\",\r\n  \"skylark-jquery\",\r\n   \"./jsbin\"\r\n],function (Deferred,$,jsbin) {\r\n    'use strict';\r\n    // move from render/live.js\r\n\r\n  /** ============================================================================\r\n   * JS Bin Renderer\r\n   * Messages to and from the runner.\r\n   * ========================================================================== */\r\n\r\n\r\n    var renderer = {},\r\n        $window = $(window),\r\n        $document = $(document);\r\n\r\n    /**\r\n     * Store what runner origin *should* be\r\n     * TODO this should allow anything if x-origin protection should be disabled\r\n     */\r\n    renderer.runner = {};\r\n    renderer.runner.origin = '*';\r\n\r\n    /**\r\n     * Setup the renderer\r\n     */\r\n    renderer.setup = function (runnerFrame) {\r\n      renderer.runner.window = runnerFrame.contentWindow;\r\n      renderer.runner.iframe = runnerFrame;\r\n    };\r\n\r\n    /**\r\n     * Log error messages, indicating that it's from the renderer.\r\n     */\r\n    renderer.error = function () {\r\n      // it's quite likely that the error that fires on this handler actually comes\r\n      // from another service on the page, like a browser plugin, which we can\r\n      // safely ignore.\r\n      window.console.warn.apply(console, ['Renderer:'].concat([].slice.call(arguments)));\r\n    };\r\n\r\n    /**\r\n     * Handle all incoming postMessages to the renderer\r\n     */\r\n    renderer.handleMessage = function (event) {\r\n      if (!event.origin) return;\r\n      var data = event.data;\r\n\r\n      if (typeof data !== 'string') {\r\n        // this event isn't for us (i.e. comes from a browser ext)\r\n        return;\r\n      }\r\n\r\n      // specific change to handle reveal embedding\r\n      /*\r\n       // Unnecessary? //lwf\r\n      try {\r\n        if (event.data.indexOf('slide:') === 0 || event.data === 'jsbin:refresh') {\r\n          // reset the state of the panel visibility\r\n          jsbin.panels.allEditors(function (p) {\r\n            p.visible = false;\r\n          });\r\n          jsbin.panels.restore();\r\n          return;\r\n        }\r\n      } catch (e) {}\r\n      */\r\n\r\n      try {\r\n        data = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;\r\n      } catch (e) {\r\n        return renderer.error('Error parsing event data:', e.message);\r\n      }\r\n\r\n      /*\r\n       // Unnecessary? //lwf\r\n      if (data.type.indexOf('code:') === 0 && jsbin.embed) {\r\n        var panel = data.type.substr(5);\r\n        if (panel === 'js') { panel = 'javascript'; }\r\n        if (' css javascript html '.indexOf(' ' + panel + ' ') === -1) {\r\n          return renderer.error('No matching event handler:', data.type);\r\n        }\r\n\r\n        if (!jsbin.state.metadata.pro) {\r\n          return renderer.error('Code injection is only supported on pro created bins');\r\n        }\r\n\r\n        jsbin.panels.named[panel].setCode(data.data);\r\n        renderLivePreview();\r\n\r\n        return;\r\n      }\r\n      */\r\n\r\n      if (typeof renderer[data.type] !== 'function') {\r\n        return false; //renderer.error('No matching handler for event', data);\r\n      }\r\n      try {\r\n        renderer[data.type](data.data);\r\n      } catch (e) {\r\n        renderer.error(e.message);\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Send message to the runner window\r\n     */\r\n    renderer.postMessage = function (type, data) {\r\n      if (!renderer.runner.window) {\r\n        return renderer.error('postMessage: No connection to runner window.');\r\n      }\r\n      renderer.runner.window.postMessage(JSON.stringify({\r\n        type: type,\r\n        data: data\r\n      }), renderer.runner.origin);\r\n    };\r\n\r\n    /**\r\n     * When the renderer is complete, it means we didn't hit an initial\r\n     * infinite loop\r\n     */\r\n    renderer.complete = function () {\r\n      try {\r\n        store.sessionStorage.removeItem('runnerPending');\r\n      } catch (e) {}\r\n    };\r\n\r\n    /**\r\n     * Pass loop protection hit calls up to the error UI\r\n     */\r\n    renderer.loopProtectHit = function (line) {\r\n      var cm = jsbin.panels.named.javascript.editor;\r\n\r\n      // grr - more setTimeouts to the rescue. We need this to go in *after*\r\n      // jshint does it's magic, but jshint set on a setTimeout, so we have to\r\n      // schedule after.\r\n      setTimeout(function () {\r\n        var annotations = cm.state.lint.annotations || [];\r\n        if (typeof cm.updateLinting !== 'undefined') {\r\n          // note: this just updated the *source* reference\r\n          annotations = annotations.filter(function (a) {\r\n            return a.source !== 'loopProtectLine:' + line;\r\n          });\r\n          annotations.push({\r\n            from: CodeMirror.Pos(line-1, 0),\r\n            to: CodeMirror.Pos(line-1, 0),\r\n            message: 'Exiting potential infinite loop.\\nTo disable loop protection: add \"// noprotect\" to your code',\r\n            severity: 'warning',\r\n            source: 'loopProtectLine:' + line\r\n          });\r\n\r\n          cm.updateLinting(annotations);\r\n        }\r\n      }, cm.state.lint.options.delay || 0);\r\n    };\r\n\r\n    /**\r\n     * When the iframe resizes, update the size text\r\n     */\r\n    renderer.resize = (function () {\r\n      var size = renderer.$live.find('.size');\r\n\r\n      var hide = throttle(function () {\r\n        size.fadeOut(200);\r\n      }, 2000);\r\n\r\n      var embedResizeDone = false;\r\n\r\n      return function (data) {\r\n        if (!jsbin.embed) {\r\n          // Display the iframe size in px in the JS Bin UI\r\n          size.show().html(data.width + 'px');\r\n          hide();\r\n        }\r\n        if (jsbin.embed && self !== top && embedResizeDone === false) {\r\n          embedResizeDone = true;\r\n          // Inform the outer page of a size change\r\n          var height = ($body.outerHeight(true) - $(renderer.runner.iframe).height()) + data.offsetHeight;\r\n         window.parent.postMessage({ height: height }, '*');\r\n        }\r\n      };\r\n    }());\r\n\r\n    /**\r\n     * When the iframe focuses, simulate that here\r\n     */\r\n    renderer.focus = function () {\r\n      jsbin.panels.focus(jsbin.panels.named.live);\r\n      // also close any open dropdowns\r\n      closedropdown();\r\n    };\r\n\r\n    /**\r\n     * Proxy console logging to JS Bin's console\r\n     */\r\n    renderer.console = function (data) {\r\n      var method = data.method,\r\n          args = data.args;\r\n\r\n      if (!window._console) {return;}\r\n      if (!window._console[method]) {method = 'log';}\r\n\r\n      // skip the entire console rendering if the console is hidden\r\n      ///if (!jsbin.panels.named.console.visible) { return; }\r\n\r\n      window._console[method].apply(window._console, args);\r\n    };\r\n\r\n    /**\r\n     * Load scripts into rendered iframe\r\n     */\r\n    renderer['console:load:script:success'] = function (url) {\r\n      $document.trigger('console:load:script:success', url);\r\n    };\r\n\r\n    renderer['console:load:script:error'] = function (err) {\r\n      $document.trigger('console:load:script:error', err);\r\n    };\r\n\r\n    /**\r\n     * Load DOME into rendered iframe\r\n     * TODO abstract these so that they are automatically triggered\r\n     */\r\n    renderer['console:load:dom:success'] = function (url) {\r\n      $document.trigger('console:load:dom:success', url);\r\n    };\r\n\r\n    renderer['console:load:dom:error'] = function (err) {\r\n      $document.trigger('console:load:dom:error', err);\r\n    };\r\n\r\n\r\n   // Runner iframe  \r\n   var  iframe,\r\n        inited;\r\n  /**\r\n   * Render live preview.\r\n   * Create the runner iframe, and if postMe wait until the iframe is loaded to\r\n   * start postMessaging the runner.\r\n   */\r\n  function init($live,runner) {\r\n\r\n    if (inited) {\r\n      return inited.promise;\r\n    }\r\n\r\n    inited = new Deferred();\r\n\r\n    renderer.$live = $live;\r\n\r\n    // Basic mode\r\n    // This adds the runner iframe to the page. It's only run once.\r\n    //if (!$live.find('iframe').length) {\r\n      iframe = document.createElement('iframe');\r\n      iframe.setAttribute('class', 'stretch');\r\n      iframe.setAttribute('sandbox', 'allow-modals allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts');\r\n      iframe.setAttribute('frameBorder', '0');\r\n      iframe.setAttribute('name', '<proxy>');\r\n      $live.prepend(iframe);\r\n      iframe.src = jsbin.runner;\r\n      try {\r\n        iframe.contentWindow.name = '/' + jsbin.state.code + '/' + jsbin.state.revision;\r\n      } catch (e) {\r\n        // ^- this shouldn't really fail, but if we're honest, it's a fucking mystery as to why it even works.\r\n        // problem is: if this throws (because iframe.contentWindow is undefined), then the execution exits\r\n        // and `var renderLivePreview` is set to undefined. The knock on effect is that the calls to renderLivePreview\r\n        // then fail, and jsbin doesn't boot up. Tears all round, so we catch.\r\n      }\r\n    //}\r\n\r\n    iframe.onload = function () {\r\n      if (window.postMessage) {\r\n        // setup postMessage listening to the runner\r\n        $window.on('message', function (event) {\r\n          renderer.handleMessage(event.originalEvent)\r\n        });\r\n        renderer.setup(iframe);\r\n        inited.resolve();\r\n      }\r\n    };\r\n\r\n    iframe.onerror = function(err) {\r\n      inited.reject(err);\r\n    };\r\n\r\n    /**\r\n     * Events\r\n     */\r\n\r\n    $document.on('codeChange.live', function (event, arg) {\r\n      if (arg.origin === 'setValue' || arg.origin === undefined) {\r\n        return;\r\n      }\r\n      store.sessionStorage.removeItem('runnerPending');\r\n    });\r\n\r\n    // Listen for console input and post it to the iframe\r\n    $document.on('console:run', function (event, cmd) {\r\n      renderer.postMessage('console:run', cmd);\r\n    });\r\n\r\n    $document.on('console:load:script', function (event, url) {\r\n      renderer.postMessage('console:load:script', url);\r\n    });\r\n\r\n    $document.on('console:load:dom', function (event, html) {\r\n      renderer.postMessage('console:load:dom', html);\r\n    });\r\n\r\n    return inited.promise;\r\n  }\r\n\r\n\r\n  return jsbin.renderer = renderer;\r\n\r\n});\r\n\ndefine('skylark-jsbin-render/main',[\r\n\t\"./renderer\"\r\n],function(renderer){\r\n\treturn renderer;\r\n});\ndefine('skylark-jsbin-render', ['skylark-jsbin-render/main'], function (main) { return main; });\n\n"]}